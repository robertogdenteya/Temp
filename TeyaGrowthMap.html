<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Teya Growth Map — Logo Markers over Time</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Marker Clusters -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- Papa Parse -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root { --blue:#008BB9; --lime:#E0E722; }
    html, body { height:100%; margin:0; }
    body { font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #map { position:absolute; inset:0; }
    .panel{
      position:absolute; left:12px; top:12px; z-index:500;
      background:#fff; border:1px solid #ddd; border-radius:10px;
      padding:10px 12px; box-shadow:0 6px 20px rgba(0,0,0,.08);
      display:flex; flex-direction:column; gap:10px; min-width:340px;
    }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .count { margin-left:auto; font-variant-numeric:tabular-nums; font-weight:600; }
    .slider { width:100%; display:grid; grid-template-columns:1fr 72px; gap:8px; align-items:center; }
    input[type=range]{ width:100%; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    button, select{ padding:6px 10px; border:1px solid #ccc; border-radius:8px; background:#fff; cursor:pointer; }
    button:disabled{ opacity:.6; cursor:not-allowed; }
    .note{ color:#666; font-size:12px; }
    /* Optional: style cluster icons to be Teya-blue */
    .marker-cluster-small, .marker-cluster-medium, .marker-cluster-large {
      background: rgba(0,139,185,0.35);
    }
    .marker-cluster div {
      background: #008BB9; color:#fff; border:2px solid #fff;
      border-radius:999px; width:30px; height:30px; line-height:26px;
      text-align:center; font-weight:700;
      box-shadow:0 2px 8px rgba(0,0,0,.15);
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="panel">
    <div class="row">
      <strong>Teya growth by month</strong>
      <span class="count" id="totalCount">0</span>
    </div>

    <div class="row">
      <button id="playBtn">▶ Play</button>
      <select id="modeSel" title="Visualisation mode">
        <option value="cluster" selected>Clusters (logo markers)</option>
        <option value="logos">All logos (no clustering)</option>
      </select>
      <button id="fitBtn" title="Fit to data">Fit</button>
    </div>

    <div class="slider">
      <input id="monthSlider" type="range" min="0" max="0" step="1" value="0">
      <div>
        <div id="monthLabel" class="mono">—</div>
        <div id="rangeLabel" class="note">—</div>
      </div>
    </div>

    <div class="note">
      CSV: <span class="mono" id="csvName">merchantmapoct25-dates.csv</span>
      <span id="status" class="count">Loading…</span>
    </div>
    <div class="note" id="debugNote"></div>
  </div>

<script>
/* === CONFIG === */
const CSV_PATH = "merchantmapoct25-dates.csv"; // same folder as this HTML
const COLS = {
  name: "MERCHANT_NAME",
  activity: "BUSINESS_ACTIVITY",
  date: "START_OF_MERCHANT_REPORTING",
  lat: "Latitude",
  lon: "Longitude"
};
const MAX_PLAIN_LOGOS = 50000; // safety cap for no-cluster mode

/* === MAP === */
const map = L.map('map', { preferCanvas:true }).setView([51.5, -0.1], 5);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18, attribution: '&copy; OpenStreetMap' }).addTo(map);

/* Custom Teya logo icon */
const teyaIcon = L.icon({
  iconUrl: 'teya-icon.png',   // must be in the same folder
  iconSize: [22, 22],         // adjust if needed (try 18–24)
  iconAnchor: [11, 11],       // center the icon
  popupAnchor: [0, -11],
  tooltipAnchor: [0, -11]
});

const statusEl = document.getElementById('status');
const debugEl  = document.getElementById('debugNote');
const totalEl  = document.getElementById('totalCount');
const slider   = document.getElementById('monthSlider');
const monthLab = document.getElementById('monthLabel');
const rangeLab = document.getElementById('rangeLabel');
const playBtn  = document.getElementById('playBtn');
const modeSel  = document.getElementById('modeSel');
const fitBtn   = document.getElementById('fitBtn');

let points = [];     // [{lat,lon,date,ym,name,activity}]
let months = [];     // ['YYYY-MM', ...]
let monthEnd = {};   // map ym -> cumulative end index

// Layers
let clusterLayer = L.markerClusterGroup({ chunkedLoading:true });
map.addLayer(clusterLayer);
let plainLogoLayer = L.layerGroup(); // used when "All logos" mode is selected

// Cache markers so we don't recreate them on every slider move
let markers = []; // same order as points

/* === Helpers === */
const fmtYM = d => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
function parseUK(s){
  // dd/mm/yyyy preferred
  const m = String(s||"").match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
  if (m) return new Date(+m[3], +m[2]-1, +m[1]);
  const d = new Date(s); // fallback
  return isNaN(d) ? null : d;
}
function updateLabels(idx){
  const ym = months[idx] || "—";
  monthLab.textContent = ym;
  if (months.length) rangeLab.textContent = `${months[0]} → ${months[months.length-1]}`;
}

function setMode(mode){
  if (mode === 'cluster') {
    if (!map.hasLayer(clusterLayer)) map.addLayer(clusterLayer);
    if (map.hasLayer(plainLogoLayer)) map.removeLayer(plainLogoLayer);
  } else {
    if (!map.hasLayer(plainLogoLayer)) map.addLayer(plainLogoLayer);
    if (map.hasLayer(clusterLayer)) map.removeLayer(clusterLayer);
  }
}

function setView(idx){
  const ym = months[idx], end = monthEnd[ym] ?? -1;
  if (end < 0){
    totalEl.textContent = "0";
    clusterLayer.clearLayers();
    plainLogoLayer.clearLayers();
    return;
  }
  const count = end + 1;
  totalEl.textContent = count.toLocaleString();

  if (modeSel.value === 'cluster') {
    // Cluster mode: just reset to the cumulative subset
    clusterLayer.clearLayers();
    clusterLayer.addLayers(markers.slice(0, count));
  } else {
    // All-logo mode (no clustering): cap to avoid lockups
    plainLogoLayer.clearLayers();
    const slice = markers.slice(Math.max(0, count - MAX_PLAIN_LOGOS), count);
    slice.forEach(m => plainLogoLayer.addLayer(m));
  }
}

function fit(){
  if (!points.length) return;
  const lats = points.map(p=>p.lat), lons = points.map(p=>p.lon);
  map.fitBounds([[Math.min(...lats), Math.min(...lons)], [Math.max(...lats), Math.max(...lons)]], { padding:[30,30] });
}

/* === UI === */
slider.addEventListener('input', ()=>{ const i=+slider.value; updateLabels(i); setView(i); });
modeSel.addEventListener('change', ()=>{ setMode(modeSel.value); setView(+slider.value); });
let playTimer = null;
playBtn.addEventListener('click', ()=>{
  if (playTimer){ clearInterval(playTimer); playTimer=null; playBtn.textContent="▶ Play"; return; }
  playBtn.textContent="⏸ Pause";
  playTimer = setInterval(()=>{
    let i=+slider.value; if (i>=+slider.max){ clearInterval(playTimer); playTimer=null; playBtn.textContent="▶ Play"; return; }
    slider.value=i+1; slider.dispatchEvent(new Event('input'));
  }, 600);
});
fitBtn.addEventListener('click', fit);

/* === Fetch, parse, build === */
(async function load(){
  try {
    statusEl.textContent = "Downloading CSV…";
    const res = await fetch(CSV_PATH + "?t=" + Date.now(), { cache: "no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const text = await res.text();

    statusEl.textContent = "Parsing CSV…";
    const parsed = Papa.parse(text, {
      header: true,
      skipEmptyLines: true,
      delimitersToGuess: [",", ";", "\t", "|"]
    });

    const headers = parsed.meta?.fields || (parsed.data[0] ? Object.keys(parsed.data[0]) : []);
    const required = [COLS.lon, COLS.lat, COLS.date];
    const missing = required.filter(h => !headers.includes(h));
    const debugEl = document.getElementById('debugNote');
    debugEl.innerHTML = "Headers: " + headers.map(h=>`<code>${h}</code>`).join(", ") +
      (missing.length ? ` <span class="note">| Missing expected: ${missing.join(", ")}</span>` : "");
    if (missing.length){ statusEl.textContent = "Expected columns not found in CSV."; return; }

    const raw = [];
    for (const row of parsed.data){
      const lat = parseFloat(String(row[COLS.lat]).replace(",", "."));
      const lon = parseFloat(String(row[COLS.lon]).replace(",", "."));
      if (!isFinite(lat) || !isFinite(lon)) continue;
      const d = parseUK(row[COLS.date]); if (!d) continue;
      raw.push({ lat, lon, date:d, ym:fmtYM(d), name:row[COLS.name]||"", activity:row[COLS.activity]||"" });
    }
    if (!raw.length){ statusEl.textContent = "No valid rows with coords + date."; return; }

    raw.sort((a,b)=>a.date-b.date);
    points = raw;

    // Prebuild all markers once (keeps slider snappy)
    markers = points.map(p => L.marker([p.lat,p.lon], { icon: teyaIcon })
      .bindTooltip(
        `<strong>${p.name||""}</strong><br>${p.activity||""}<br><span class="mono">${p.ym}</span>`,
        {direction:'top'}
      )
    );

    // Build month index
    const start = new Date(points[0].date.getFullYear(), points[0].date.getMonth(), 1);
    const end   = new Date();
    months = [];
    const cur = new Date(start);
    while (cur <= end){ months.push(fmtYM(cur)); cur.setMonth(cur.getMonth()+1); }
    let j=0; monthEnd={};
    for (const ym of months){ while (j<points.length && points[j].ym <= ym) j++; monthEnd[ym]=j-1; }

    // Init UI
    slider.min = 0; slider.max = Math.max(0, months.length-1); slider.value = slider.max;
    updateLabels(+slider.value);
    setMode(modeSel.value); // default clusters
    setView(+slider.value);
    fit();

    statusEl.textContent = `Loaded ${points.length.toLocaleString()} merchants across ${months.length} months`;
  } catch (e){
    statusEl.textContent = "Error: " + (e.message || e);
  }
})();
</script>
</body>
</html>
