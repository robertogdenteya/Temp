<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Teya Merchant Map (Leaflet + Geoapify)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <!-- Marker clustering (recommended) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- CSV parser -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; }
    .status {
      position: absolute; z-index: 500; top: 10px; left: 10px;
      background: #fff; padding: 8px 10px; border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,.15); font: 14px/1.35 system-ui, sans-serif;
      max-width: 420px;
    }
    .tt { line-height: 1.2; }  /* tooltip text */
    .tt strong { display:block; } /* name on its own line */
    .muted { opacity: .75; }
    a.small { font-size: 12px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="status" class="status">
    <strong>Teya Merchant Map</strong><br>
    <span class="muted">Loading <code>merchantmap-oct2025.csv</code>…</span>
  </div>

  <script>
    // ===== CONFIG =====
    const GEOAPIFY_KEY = "994b9182b34b40378d2116c40baa4faa"; // e.g. "994b9182b34b40378d2116c40baa4faa"
    const CSV_PATH = "merchantmap-oct2025.csv"; // same repo, same folder

    // Map your CSV column names here (edit if your headers differ)
    const COLS = {
      name: "MERCHANT_NAME",
      activity: "BUSINESS_ACTIVITY",
      street: "address.street",
      city: "address.city",
      zip: "address.zip",
      country: "country" // optional
    };

    // Optional: help geocoder accuracy/speed (e.g. "countrycode:gb,cz,pt")
    const GEOAPIFY_FILTER = ""; // e.g. "countrycode:gb"
    const GEOAPIFY_BIAS   = ""; // e.g. "countrycode:gb"

    // ===== MAP INIT (Geoapify tiles + attribution) =====
    const map = L.map('map').setView([51.5074, -0.1278], 6); // start over the UK
    const isRetina = L.Browser.retina;
    const tileUrl = isRetina
      ? `https://maps.geoapify.com/v1/tile/osm-bright/{z}/{x}/{y}@2x.png?apiKey=${GEOAPIFY_KEY}`
      : `https://maps.geoapify.com/v1/tile/osm-bright/{z}/{x}/{y}.png?apiKey=${GEOAPIFY_KEY}`;

    L.tileLayer(tileUrl, {
      maxZoom: 20,
      attribution:
        '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, ' +
        '© <a href="https://www.openmaptiles.org/">OpenMapTiles</a>, ' +
        '<a href="https://www.geoapify.com/">Powered by Geoapify</a>'
    }).addTo(map);

    const cluster = L.markerClusterGroup();
    map.addLayer(cluster);

    const statusEl = document.getElementById("status");

    // ===== Helpers =====
    function esc(s=""){
      return s.replace(/[&<>"'`=\/]/g, c =>
        ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','/':'&#x2F;','`':'&#x60;','=':'&#x3D;'}[c])
      );
    }

    function buildAddress(row) {
      const parts = [
        (row[COLS.street] || "").trim(),
        (row[COLS.city]   || "").trim(),
        (row[COLS.zip]    || "").trim(),
      ].filter(Boolean);
      const base = parts.join(", ");
      const country = (row[COLS.country] || "").trim();
      return country ? `${base}, ${country}` : base;
    }

    function tooltipHtml(row, fullAddr) {
      const name = esc(row[COLS.name] || "(Unnamed)");
      const act  = esc(row[COLS.activity] || "—");
      const addr = esc(fullAddr || "—");
      return `<div class="tt"><strong>${name}</strong>${act}<br>${addr}</div>`;
    }

    // Cache (localStorage) to avoid re-geocoding same addresses
    const geocodeCache = new Map();
    loadCache();
    function loadCache(){
      try{
        const raw = localStorage.getItem("geocodeCache");
        if (!raw) return;
        const obj = JSON.parse(raw);
        for (const [k,v] of Object.entries(obj)) geocodeCache.set(k, v);
      } catch {}
    }
    function saveCache(){
      localStorage.setItem("geocodeCache", JSON.stringify(Object.fromEntries(geocodeCache)));
    }

    // Rate-limited queue (keep gentle to avoid 429s)
    const queue = [];
    let running = false;
    const RPS = 5;
    const INTERVAL_MS = Math.ceil(1000 / RPS);
    function enqueue(fn){ queue.push(fn); if (!running) runQueue(); }
    async function runQueue(){
      running = true;
      while(queue.length){
        await queue.shift()();
        await new Promise(r => setTimeout(r, INTERVAL_MS));
      }
      running = false;
    }

    async function geocodeAddress(address){
      const key = address.trim().toLowerCase();
      if (!key) throw new Error("Empty address");
      if (geocodeCache.has(key)) return geocodeCache.get(key);

      const url = new URL("https://api.geoapify.com/v1/geocode/search");
      url.searchParams.set("text", address);
      url.searchParams.set("apiKey", GEOAPIFY_KEY);
      if (GEOAPIFY_FILTER) url.searchParams.set("filter", GEOAPIFY_FILTER);
      if (GEOAPIFY_BIAS)   url.searchParams.set("bias", GEOAPIFY_BIAS);

      const res = await fetch(url);
      if (!res.ok) throw new Error(`Geocode failed: ${res.status} ${res.statusText}`);
      const data = await res.json();
      const feature = data.features && data.features[0];
      if (!feature) throw new Error(`No result for: ${address}`);

      const [lon, lat] = feature.geometry.coordinates;
      const result = { lat, lon, raw: feature };
      geocodeCache.set(key, result);
      saveCache();
      return result;
    }

    // ===== Load CSV from the repo (via relative path) =====
    // This works cleanly on GitHub Pages (no CORS issues) because both files are served from the same origin.
    fetch(CSV_PATH)
      .then(r => {
        if (!r.ok) throw new Error(`CSV fetch failed: ${r.status} ${r.statusText}`);
        return r.text();
      })
      .then(text => {
        statusEl.innerHTML = `Parsing <code>${CSV_PATH}</code>…`;
        Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          complete: ({ data: rows }) => plotRows(rows),
          error: (err) => statusEl.innerHTML = `CSV parse error: ${esc(err.message)}`
        });
      })
      .catch(err => {
        statusEl.innerHTML = `Error loading <code>${CSV_PATH}</code>: ${esc(err.message)}<br>
          <span class="muted">Ensure the CSV is in the repo root next to <code>tempmap2.html</code>.</span>`;
      });

    function plotRows(rows){
      if (!rows.length){
        statusEl.textContent = "No rows found in CSV.";
        return;
      }
      let processed = 0, failures = 0;
      const bounds = L.latLngBounds([]);

      new Promise(resolve => {
        rows.forEach(row => {
          const fullAddr = buildAddress(row);
          if (!fullAddr){ failures++; tick(); return; }

          enqueue(async () => {
            try{
              const { lat, lon } = await geocodeAddress(fullAddr);
              const marker = L.marker([lat, lon]);

              // Hover tooltip (and popup for mobile)
              marker.bindTooltip(tooltipHtml(row, fullAddr), { direction: "top", opacity: 0.9 });
              marker.bindPopup(tooltipHtml(row, fullAddr));

              cluster.addLayer(marker);
              bounds.extend([lat, lon]);
            } catch(e){
              console.warn(e.message);
              failures++;
            } finally {
              tick();
            }
          });
        });

        function tick(){
          processed++;
          statusEl.innerHTML = `Geocoded ${processed}/${rows.length} (failures: ${failures})…`;
          if (processed === rows.length){
            if (bounds.isValid()) map.fitBounds(bounds.pad(0.15));
            statusEl.innerHTML = `Done. Plotted ${rows.length - failures} / ${rows.length}. ` +
              `<a class="small" href="${location.href}" title="Reload">Reload</a>`;
            resolve();
          }
        }
      });
    }
  </script>
</body>
</html>
