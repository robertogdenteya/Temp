<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Teya Growth Map — Quarterly Hexbin (No Plugin)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- D3 v5 + d3-hexbin (we draw with SVG directly; no Leaflet hexbin plugin) -->
<script src="https://unpkg.com/d3@5/dist/d3.min.js"></script>
<script src="https://unpkg.com/d3-hexbin@0.2.2/build/d3-hexbin.min.js"></script>

<!-- Papa Parse -->
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

<style>
  :root { --blue:#008BB9; --lime:#E0E722; --ink:#111827; }
  html, body { height:100%; margin:0; background:#fff; }
  body { font:13px/1.45 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; color:var(--ink); }
  #map { position:absolute; inset:0; }

  /* Compact HUD */
  .hud { position:absolute; left:12px; top:12px; z-index:500; display:flex; gap:6px; }
  .toolbar {
    background: rgba(255,255,255,0.75); border:1px solid rgba(17,24,39,0.08); backdrop-filter: blur(6px);
    border-radius:10px; padding:6px 8px; box-shadow:0 6px 18px rgba(0,0,0,.06);
    display:flex; align-items:center; gap:8px;
  }
  .btn, select {
    appearance:none; -webkit-appearance:none; font:inherit;
    padding:4px 8px; border:1px solid #d1d5db; border-radius:8px; background:#fff;
    line-height:1.1; height:26px; cursor:pointer;
  }
  .btn.primary { background:var(--blue); color:#fff; border-color:var(--blue); }

  .range-wrap { display:flex; align-items:center; gap:8px; min-width:220px; }
  .range {
    -webkit-appearance:none; appearance:none; width:100%; height:4px; border-radius:999px; background:#e5e7eb; outline:none;
  }
  .range::-webkit-slider-thumb {
    -webkit-appearance:none; appearance:none; width:14px; height:14px; border-radius:50%;
    background:var(--blue); border:2px solid #fff; box-shadow:0 1px 4px rgba(0,0,0,.25); cursor:pointer; margin-top:-5px;
  }
  .range::-moz-range-thumb {
    width:14px; height:14px; border-radius:50%;
    background:var(--blue); border:2px solid #fff; box-shadow:0 1px 4px rgba(0,0,0,.25); cursor:pointer;
  }

  /* Bottom-left tiny status */
  .chip {
    position:absolute; left:12px; bottom:12px; z-index:500;
    background:rgba(255,255,255,0.75); border:1px solid rgba(17,24,39,0.08);
    border-radius:999px; padding:4px 8px; font-variant-numeric: tabular-nums; box-shadow:0 6px 18px rgba(0,0,0,.06);
  }
  .chip code { background:transparent; padding:0; }

  /* On-map quarter label */
  .q-label {
    font-weight:800; letter-spacing:0.01em; font-size: clamp(24px,3.2vw,42px); color:#0c1f27;
    background:rgba(255,255,255,0.72); border:1px solid rgba(17,24,39,0.08);
    border-radius:12px; padding:6px 10px; box-shadow:0 6px 18px rgba(0,0,0,.06);
    backdrop-filter: blur(6px); user-select:none; pointer-events:none; white-space:nowrap;
  }
</style>
</head>
<body>
  <div id="map"></div>

  <div class="hud">
    <div class="toolbar">
      <button id="playBtn" class="btn primary" title="Play/Pause">▶</button>
      <div class="range-wrap"><input id="qSlider" class="range" type="range" min="0" max="0" step="1" value="0" /></div>
      <select id="modeSel" title="Aggregation">
        <option value="cum" selected>Cumulative</option>
        <option value="quarter">This quarter only</option>
      </select>
      <select id="scaleSel" title="Colour scale">
        <option value="lime" selected>Lime (brand)</option>
        <option value="blue">Blue</option>
      </select>
      <select id="hexSize" title="Hex size">
        <option value="10">Fine</option>
        <option value="14" selected>Normal</option>
        <option value="18">Coarse</option>
        <option value="22">Very coarse</option>
      </select>
      <button id="fitBtn" class="btn" title="Fit to data">Fit</button>
    </div>
  </div>

  <div class="chip"><span id="totalCount">0</span> merchants • CSV <code>merchantmapoct25-dates.csv</code></div>

<script>
/* === CSV & columns === */
const CSV_PATH = "merchantmapoct25-dates.csv";
const COLS = {
  name: "MERCHANT_NAME",
  activity: "BUSINESS_ACTIVITY",
  date: "START_OF_MERCHANT_REPORTING",
  lat: "Latitude",
  lon: "Longitude"
};

/* === Map === */
const map = L.map('map', { preferCanvas:true }).setView([55.5, -3], 5);
L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
  maxZoom: 19, attribution: '&copy; OSM & CARTO'
}).addTo(map);

// --- Add a pane for labels so they don't block interactions ---
map.createPane('labels');
map.getPane('labels').style.pointerEvents = 'none';
map.getPane('labels').style.zIndex = 650; // above hexes and base map

// --- Add a labels-only tile layer (country & city names) ---
const labelsOnly = L.tileLayer(
  'https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png',
  {
    pane: 'labels',
    maxZoom: 19,
    opacity: 0.95,
    attribution: '&copy; OSM & CARTO'
  }
).addTo(map);

/* Use Leaflet's own SVG renderer (fixes clipping on zoom/pan) */
const leafletSvg = L.svg({ padding: 0.75 }).addTo(map); // padding adds overscan so edges aren't clipped
const svg = d3.select(leafletSvg._container);           // Leaflet-managed <svg>
const g   = svg.append("g").attr("class","hex-layer");

/* On-map quarterly label (between Iceland & UK) */
const OVERLAY_POS = [60.8, -11];
let qMarker = L.marker(OVERLAY_POS, {
  interactive:false, zIndexOffset:10000,
  icon: L.divIcon({ className:'', html:'<div class="q-label">—</div>', iconSize:[0,0] })
}).addTo(map);
const setQText = t => { const el = qMarker.getElement(); if (el) el.querySelector('.q-label').textContent = t || '—'; };

/* === State === */
let points = [], quarters = [], qEnd = {}, playTimer = null;
const totalEl  = document.getElementById('totalCount');
const playBtn  = document.getElementById('playBtn');
const slider   = document.getElementById('qSlider');
const modeSel  = document.getElementById('modeSel');
const scaleSel = document.getElementById('scaleSel'); // default = lime
const hexSize  = document.getElementById('hexSize');
const fitBtn   = document.getElementById('fitBtn');

/* === Helpers (quarters) === */
const qKey   = d => `${d.getFullYear()}-Q${Math.floor(d.getMonth()/3)+1}`;
const qHuman = key => { if(!key) return '—'; const [y,q] = key.split('-Q'); return `Q${q} ${y}`; };
function parseUK(s){
  const m = String(s||"").match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
  if (m) return new Date(+m[3], +m[2]-1, +m[1]);
  const d = new Date(s);
  return isNaN(d) ? null : d;
}

/* === Hexbin render (using Leaflet's SVG; no manual sizing needed) === */
function renderHexes(latlngs){
  // Project lat/lon to the SVG's local coordinate space
  const projected = latlngs.map(([lat,lon])=>{
    const pt = map.latLngToLayerPoint([lat,lon]);
    return {x:pt.x, y:pt.y};
  });

  const radius = parseInt(hexSize.value,10) || 14;
  const hexbin = d3.hexbin().radius(radius).x(d=>d.x).y(d=>d.y);
  const bins = hexbin(projected);

  // Colour scales (stronger lime by default)
  let maxCount = d3.max(bins, b=>b.length) || 1;

// Avoid overly dark colours when data are sparse
if (maxCount < 3) maxCount = 3;
  const color = (scaleSel.value === 'blue')
    ? d3.scaleSequential(d3.interpolateGnBu).domain([0, maxCount])
    : d3.scaleLinear()
        .domain([0, maxCount*0.5, maxCount])
        .range(['#f1f3b6', '#E0E722', '#D4D72C']) // lighter start -> brand lime -> deeper lime
        .clamp(true);

  // JOIN
  const sel = g.selectAll("path.hex").data(bins, d=>d.x+"-"+d.y);

  // EXIT
  sel.exit().remove();

  // UPDATE
  sel.attr("transform", d=>`translate(${d.x},${d.y})`)
     .attr("d", hexbin.hexagon())
     .attr("fill", d=>color(d.length))
     .attr("fill-opacity", 0.9)
     .attr("stroke", "rgba(255,255,255,0.9)")
     .attr("stroke-width", 0.5);

  // ENTER
  sel.enter().append("path")
     .attr("class","hex")
     .attr("transform", d=>`translate(${d.x},${d.y})`)
     .attr("d", hexbin.hexagon(0))
     .attr("fill", d=>color(d.length))
     .attr("fill-opacity", 0.9)
     .attr("stroke", "rgba(255,255,255,0.9)")
     .attr("stroke-width", 0.5)
     .transition().duration(120)
     .attr("d", hexbin.hexagon());
}

/* === Update view for a given quarter index === */
function setView(idx){
  const q = quarters[idx];
  setQText(qHuman(q));
  const end = qEnd[q] ?? -1;
  if (end < 0) { totalEl.textContent="0"; renderHexes([]); return; }

  let data=[];
  if (modeSel.value === 'cum') {
    data = points.slice(0, end+1).map(p=>[p.lat,p.lon]);
  } else {
    const prev = (idx>0) ? (qEnd[quarters[idx-1]] ?? -1) : -1;
    data = points.slice(prev+1, end+1).map(p=>[p.lat,p.lon]);
  }
  totalEl.textContent = (modeSel.value==='cum' ? (end+1) : data.length).toLocaleString();
  renderHexes(data);
}

/* === Fit bounds === */
function fit(){
  if(!points.length) return;
  const lats = points.map(p=>p.lat), lons = points.map(p=>p.lon);
  map.fitBounds([[Math.min(...lats),Math.min(...lons)], [Math.max(...lats),Math.max(...lons)]], { padding:[24,24] });
}

/* === Events === */
slider.addEventListener('input', ()=>setView(+slider.value));
[modeSel, scaleSel, hexSize].forEach(el=>el.addEventListener('change', ()=>setView(+slider.value)));
fitBtn.addEventListener('click', fit);

// Re-render on pan/zoom (Leaflet's SVG takes care of sizing; we just reproject)
map.on('move zoom moveend zoomend', ()=>setView(+slider.value));

// Play (fast: 150ms)
playBtn.addEventListener('click', ()=>{
  if (playTimer){ clearInterval(playTimer); playTimer=null; playBtn.textContent="▶"; return; }
  playBtn.textContent="⏸";
  playTimer = setInterval(()=>{
    let i=+slider.value;
    if (i>=+slider.max){ clearInterval(playTimer); playTimer=null; playBtn.textContent="▶"; return; }
    slider.value=i+1; slider.dispatchEvent(new Event('input'));
  }, 150);
});

/* === Load data & build quarters === */
(async function(){
  try{
    const res = await fetch(CSV_PATH + "?t=" + Date.now(), { cache:"no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const text = await res.text();
    const parsed = Papa.parse(text, { header:true, skipEmptyLines:true, delimitersToGuess:[",",";","\t","|"] });
    const headers = parsed.meta?.fields || (parsed.data[0] ? Object.keys(parsed.data[0]) : []);
    if (["Longitude","Latitude","START_OF_MERCHANT_REPORTING"].some(h => !headers.includes(h))) {
      alert("Expected columns not found in CSV."); return;
    }

    const rows=[];
    for (const r of parsed.data){
      const lat = parseFloat(String(r[COLS.lat]).replace(",", "."));
      const lon = parseFloat(String(r[COLS.lon]).replace(",", "."));
      if (!isFinite(lat) || !isFinite(lon)) continue;
      const d = parseUK(r[COLS.date]); if (!d) continue;
      rows.push({ lat, lon, date:d, q:qKey(d) });
    }
    if (!rows.length) { alert("No valid rows with coordinates + date."); return; }
    rows.sort((a,b)=>a.date-b.date);
    points = rows;

    // Quarter sequence
    const startQ = qKey(new Date(rows[0].date.getFullYear(), Math.floor(rows[0].date.getMonth()/3)*3, 1));
    const now = new Date(); const endQ = qKey(now);
    quarters = [];
    let yq = startQ.split('-Q'); let y = +yq[0], q = +yq[1];
    while (true) { quarters.push(`${y}-Q${q}`); if (`${y}-Q${q}`===endQ) break; q++; if (q>4) { q=1; y++; } }

    // Quarter -> cumulative end index
    let j=0; qEnd = {};
    for (const Q of quarters) { while (j<points.length && points[j].q <= Q) j++; qEnd[Q] = j-1; }

    slider.min = 0; slider.max = Math.max(0, quarters.length-1); slider.value = slider.max;

    // Initial draw
    setView(+slider.value);
    fit();
  } catch(e){
    console.error(e);
    alert("Error: " + (e.message || e));
  }
})();
</script>
</body>
</html>
