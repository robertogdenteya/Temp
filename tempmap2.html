<!-- … keep everything above the <script> the same as your current vanilla file … -->

<script>
/* === CSV & columns === */
const CSV_PATH="merchantmapoct25-dates.csv";
const COLS={ name:"MERCHANT_NAME", activity:"BUSINESS_ACTIVITY", date:"START_OF_MERCHANT_REPORTING", lat:"Latitude", lon:"Longitude" };

/* === Map === */
const map=L.map('map',{preferCanvas:true}).setView([55.5,-3],5);
L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png',{maxZoom:19,attribution:'&copy; OSM & CARTO'}).addTo(map);

/* On-map quarterly label (between Iceland & UK) */
const OVERLAY_POS=[60.8,-11];
let qMarker=L.marker(OVERLAY_POS,{interactive:false,zIndexOffset:10000,icon:L.divIcon({className:'',html:'<div class="q-label">—</div>',iconSize:[0,0]})}).addTo(map);
const setQText=t=>{const el=qMarker.getElement(); if(el) el.querySelector('.q-label').textContent=t||'—';};

/* === D3 SVG overlay bound to Leaflet’s overlay pane === */
const svg = d3.select(map.getPanes().overlayPane).append("svg").style("position","absolute");
const g   = svg.append("g").attr("class","hex-layer");

/* === State === */
let points=[], quarters=[], qEnd={}, playTimer=null;
const totalEl=document.getElementById('totalCount');
const playBtn=document.getElementById('playBtn');
const slider=document.getElementById('qSlider');
const modeSel=document.getElementById('modeSel');
const scaleSel=document.getElementById('scaleSel'); // now defaults to Lime
const hexSize=document.getElementById('hexSize');
const fitBtn=document.getElementById('fitBtn');

/* === Helpers (quarters) === */
const qKey=d=>`${d.getFullYear()}-Q${Math.floor(d.getMonth()/3)+1}`;
const qHuman=key=>{if(!key)return'—'; const [y,q]=key.split('-Q'); return `Q${q} ${y}`;};
function parseUK(s){const m=String(s||"").match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/); if(m) return new Date(+m[3],+m[2]-1,+m[1]); const d=new Date(s); return isNaN(d)?null:d;}

/* === Hexbin render === */
function renderHexes(latlngs){
  // Project lat/lon to screen coords
  const projected = latlngs.map(([lat,lon])=>{
    const pt = map.latLngToLayerPoint([lat,lon]);
    return {x:pt.x, y:pt.y};
  });

  // Size & origin of the overlay SVG — with padding to avoid clipping
  const radius = parseInt(hexSize.value,10) || 14;
  const pad = radius*2 + 40; // <- generous buffer
  const bounds = map.getPixelBounds();
  const left   = bounds.min.x - pad;
  const top    = bounds.min.y - pad;
  const width  = (bounds.max.x - bounds.min.x) + pad*2;
  const height = (bounds.max.y - bounds.min.y) + pad*2;

  svg.attr("width", width)
     .attr("height", height)
     .style("left", `${left}px`)
     .style("top", `${top}px`);
  g.attr("transform", `translate(${-left},${-top})`);

  // Build hexbin in pixel space
  const hexbin = d3.hexbin().radius(radius).x(d=>d.x).y(d=>d.y);
  const bins = hexbin(projected);

  // Colour scales
  // Default = Lime (brand): light lime -> Teya Lime -> olive-lime for peaks
  const maxCount = d3.max(bins, b=>b.length) || 1;
  const color =
    (scaleSel.value==='blue')
      ? d3.scaleSequential(d3.interpolateGnBu).domain([0, maxCount])
      : d3.scaleLinear()
          .domain([0, maxCount*0.5, maxCount])
          .range(['#f6f8c8', '#E0E722', '#aeb416']) // light -> brand lime -> deeper lime
          .clamp(true);

  // JOIN
  const sel = g.selectAll("path.hex").data(bins, d=>d.x+"-"+d.y);

  // EXIT
  sel.exit().remove();

  // UPDATE
  sel.attr("transform", d=>`translate(${d.x},${d.y})`)
     .attr("d", hexbin.hexagon())
     .attr("fill", d=>color(d.length))
     .attr("fill-opacity", 0.9)
     .attr("stroke", "rgba(255,255,255,0.9)")
     .attr("stroke-width", 0.5);

  // ENTER
  sel.enter().append("path")
     .attr("class","hex")
     .attr("transform", d=>`translate(${d.x},${d.y})`)
     .attr("d", hexbin.hexagon(0))          // animate in from 0
     .attr("fill", d=>color(d.length))
     .attr("fill-opacity", 0.9)
     .attr("stroke", "rgba(255,255,255,0.9)")
     .attr("stroke-width", 0.5)
     .transition().duration(120)
     .attr("d", hexbin.hexagon());          // grow to full size
}

/* === Update view for a given quarter index === */
function setView(idx){
  const q=quarters[idx]; setQText(qHuman(q));
  const end=qEnd[q]??-1;
  if(end<0){ totalEl.textContent="0"; renderHexes([]); return; }

  let data=[];
  if(modeSel.value==='cum'){ data = points.slice(0,end+1).map(p=>[p.lat,p.lon]); }
  else{
    const prev=(idx>0)?(qEnd[quarters[idx-1]]??-1):-1;
    data = points.slice(prev+1,end+1).map(p=>[p.lat,p.lon]);
  }
  totalEl.textContent=(modeSel.value==='cum'? (end+1) : data.length).toLocaleString();
  renderHexes(data);
}

/* === Fit bounds === */
function fit(){
  if(!points.length) return;
  const lats=points.map(p=>p.lat), lons=points.map(p=>p.lon);
  map.fitBounds([[Math.min(...lats),Math.min(...lons)],[Math.max(...lats),Math.max(...lons)]],{padding:[24,24]});
}

/* === Events === */
slider.addEventListener('input',()=>setView(+slider.value));
[modeSel, scaleSel, hexSize].forEach(el=>el.addEventListener('change',()=>setView(+slider.value)));
fitBtn.addEventListener('click', fit);

// Re-render hexes when map moves/zooms (reproject to pixels) — the padding above prevents edge clipping
map.on('moveend zoomend', ()=>setView(+slider.value));

// Play (fast: 150ms)
playBtn.addEventListener('click',()=>{
  if(playTimer){ clearInterval(playTimer); playTimer=null; playBtn.textContent="▶"; return; }
  playBtn.textContent="⏸";
  playTimer=setInterval(()=>{
    let i=+slider.value;
    if(i>=+slider.max){ clearInterval(playTimer); playTimer=null; playBtn.textContent="▶"; return; }
    slider.value=i+1; slider.dispatchEvent(new Event('input'));
  },150);
});

/* === Load data & build quarters === */
(async function(){
  try{
    const res=await fetch(CSV_PATH+"?t="+Date.now(),{cache:"no-store"}); if(!res.ok) throw new Error("HTTP "+res.status);
    const text=await res.text();
    const parsed=Papa.parse(text,{header:true,skipEmptyLines:true,delimitersToGuess:[",",";","\t","|"]});
    const headers=parsed.meta?.fields || (parsed.data[0]?Object.keys(parsed.data[0]):[]);
    if(["Longitude","Latitude","START_OF_MERCHANT_REPORTING"].some(h=>!headers.includes(h))){ alert("Expected columns not found in CSV."); return; }

    const rows=[];
    for(const r of parsed.data){
      const lat=parseFloat(String(r[COLS.lat]).replace(",",".")); const lon=parseFloat(String(r[COLS.lon]).replace(",",".")); if(!isFinite(lat)||!isFinite(lon)) continue;
      const d=parseUK(r[COLS.date]); if(!d) continue;
      rows.push({lat,lon,date:d,q:qKey(d)});
    }
    if(!rows.length){ alert("No valid rows with coordinates + date."); return; }
    rows.sort((a,b)=>a.date-b.date); points=rows;

    // Quarter sequence
    const startQ=qKey(new Date(rows[0].date.getFullYear(), Math.floor(rows[0].date.getMonth()/3)*3, 1));
    const now=new Date(); const endQ=qKey(now);
    quarters=[]; let yq=startQ.split('-Q'); let y=+yq[0], q=+yq[1];
    while(true){ quarters.push(`${y}-Q${q}`); if(`${y}-Q${q}`===endQ) break; q++; if(q>4){ q=1; y++; } }

    // Quarter -> cumulative end index
    let j=0; qEnd={}; for(const Q of quarters){ while(j<points.length && points[j].q<=Q) j++; qEnd[Q]=j-1; }

    slider.min=0; slider.max=Math.max(0,quarters.length-1); slider.value=slider.max;

    // Initial draw
    setView(+slider.value);
    fit();
  }catch(e){ console.error(e); alert("Error: "+(e.message||e)); }
})();
</script>
